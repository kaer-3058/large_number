![](https://s21.ax1x.com/2024/09/13/pAnhYrt.jpg)



## ka__er's math lib v.1.16

- [English](README_English.md)

- [简体中文](README.md)

For minecraft 1.21.1

Related concepts: 16-bit BCD array, segmented storage, floating-point type, double type, leading zero, absolute value, const, precision, scientific notation. If an element in a 16-bit BCD array has less than four digits, it should be padded with 0s to make up four digits when reading the number. 

Entities in this datapack, such as world entities, display entities, and temporary entities, are all in the overworld. 

> World entity: Marker with a fixed UUID, This type of entity is usually unique worldwide, so it is called a world entity.
>
> 16-bit BCD array: If it contains 12 digits, the maximum value should be represented as [I; 9999,9999,9999], and the minimum value should be represented as [I; 0,0,0].

The file "command_storage_large_number.dat" in the "data" folder under the archive folder is where all the storage data generated by this data package is stored.

Recommended settings: `gamerule maxCommandChainLength 2147483647`

　

♦ Unique Identifier of this datapack

```
storage large_number:const version
Current Content is："large_number v.1.16"

Protocol Version：#k.la.version const
Currently is：1016
```

　

♦ Const

```
Circumference ratio π：storage large_number:const "π"
Euler's number e：storage large_number:const "e"
Euler–Mascheroni constant γ：storage large_number:const "γ"
Golden ratio φ：storage large_number:const "φ"
Not a number NaN：storage large_number:math buffer_NaN
```

　

♦ Trigonometric functions: large_number:math_trifs/_of_entity

```
Input: entity b09e-44-fded-6-efa5ffffef64 Rotation[0] 0.0f
Output: #sin int，#cos int，#tan int，#cot int，#sec int，#csc int
```

♦ sin and cos

```
input: entity b09e-44-fded-6-efa5ffffef64 Rotation[0] 0.0f

operation: execute in overworld as b09e-44-fded-6-efa5ffffef64 rotated as @s rotated ~ 0.0 positioned .0 .0 .0 run tp @s ^1.0 ^ ^ ~ ~

sin: entity b09e-44-fded-6-efa5ffffef64 Pos[2]

cos: entity b09e-44-fded-6-efa5ffffef64 Pos[0]
```

♦ atan2：

Formula：atan2d(y,x)

1.Data from the score：large_number:math_trifs/atan2

```
Input：#y int，#x int
Operation：as b09e-44-fded-6-efa5ffffef64 run func.. 
Output (degrees)：entity b09e-44-fded-6-efa5ffffef64 Rotation[0]
```

2.Data from the nbt：`execute as b09e-44-fded-6-efa5ffffef64 positioned .0 .0 .0 run function large_number:math_trifs/atan2_double/start with storage large_number:math atan2_double`

```
Input：
y：storage large_number:math atan2_double.y 1.0
x：storage large_number:math atan2_double.x 1.0
Input double or float, output float

Output (degrees)：storage large_number:math atan2_double.output
```

　

♦ arcsin and arccos

arcsin: large_number:math_trifs/arcsin

arccos: large_number:math_trifs/arccos

Formula: arcsin(x)=atan2(x,√(1-x²))，arccos(x)=atan2(√(1-x²),x)

```
Input: #arcsin_cos.input int
Enlarging the input by a factor of 10000, the input range are: [-10000, 10000]

Output (degrees): entity b09e-44-fded-6-efa5ffffef64 Rotation[0]
```

♦ arctan：`execute as b09e-44-fded-6-efa5ffffef64 positioned .0 .0 .0 run function large_number:math_trifs/arctan/start with storage large_number:math arctan`

Formula：`arctan(x)=atan2(x,1)`

```
Input：storage large_number:math arctan.input 0.0
Input double or float, output float

Output (degrees)：storage large_number:math arctan.output
```

　

♦ Large number addition: large_number:addition/start

```
Addend1: storage large_number:math addition.input1 [I;0,0,0]
Addend2: storage large_number:math addition.input2 [I;0,0,0]
Sum: storage large_number:math addition.output
```

♦ Large number subtraction: large_number:subtraction/start

```
Minuend: storage large_number:math subtraction.input1 [I;0,0,0,0]
Subtrahend: storage large_number:math subtraction.input2 [I;0,0,0,0]
Difference: storage large_number:math subtraction.output
```

　

♦ Displaying entity law for floating-point division

Note: Due to the matrix SVD, if all input values are positive, the output will always be positive. However, if the input values are negative, the output may not necessarily be positive or negative.

```
Input: The 1st, 6th, and 11th elements of the list are the dividends, and the last number is the divisor.
entity 28529-0-3d00-0-2c4200ee8401 transformation [1.0f,0.0f,0.0f,0.0f,0.0f,1.0f,0.0f,0.0f,0.0f,0.0f,1.0f,0.0f,0.0f,0.0f,0.0f,1.0f]

Output: 
entity 28529-0-3d00-0-2c4200ee8401 transformation.scale
```

♦ Displaying entity law for large number division: large_number:division/display_large_number/start

Only dealing with positive numbers.

```
Dividend
storage large_number:math display_div_large.input.dividend1 [I;0,0,0]
storage large_number:math display_div_large.input.dividend2 [I;0,0,0]
storage large_number:math display_div_large.input.dividend3 [I;0,0,0]

Divisor
storage large_number:math display_div_large.input.divisor [I;0,0,0]

Quotient list
entity 28529-0-3d00-0-2c4200ee8401 transformation.scale
```

♦ Floating-point division - Data from the score

1. 8 significant digits: large_number:division/hpo/_div

This is the core of all high-precision division methods currently, with the algorithm authored by Xiao Dou: https://github.com/xiaodou8593

```
Dividend
#float_sign int (Sign, options: -1, 0, 1, representing negative sign, zero, positive sign)
#float_int0 int (The first eight significant digits of the input value. Range is from 10000000 to 99999999 or 0)
#float_exp int (Exponent, range is a full int)

Divisor
#Divisor_float_sign int (Sign, options: -1, 0, 1, representing negative sign, zero, positive sign)
#Divisor_float_int0 int (The first eight significant digits of the input value. Range is from 10000000 to 99999999)
#Divisor_float_exp int (Exponent, range is a full int)

Example: 
set #float_sign int 1
set #float_int0 int 44553375
set #float_exp int 23
It represents the number: 1*0.44553375*10^23

Output in a way that changes the dividend
```

2. 12 significant digits: large_number:division/multi_times_modulo

```
Dividend
#float_sign int (Sign, options: -1, 0, 1, representing negative sign, zero, positive sign)
#float_int0 int (The first eight significant digits of the input value. Range is from 10000000 to 99999999 or 0)
#float_exp int (Exponent, range is a full int)

Divisor
#Divisor_float_sign int (Sign, options: -1, 0, 1, representing negative sign, zero, positive sign)
#Divisor_float_int0 int (The first eight significant digits of the input value. Range is from 10000000 to 99999999)
#Divisor_float_exp int (Exponent, range is a full int)

Quotient
#float_sign int (Sign)
#float_int0 int(First 8 digits) + #float_int1 int(9~12 digits)
#float_exp int (Exponent)

If the fractional part of #float_int1 int is less than four digits, zeros should be added at the beginning of the number to make it a four-digit number when reading it.
```

♦ Floating-point division - Data from the nbt

8 significant digits: large_number:division/float/start

12 significant digits: large_number:division/float_12decimal/start

Input float or double

```
Dividend: storage large_number:math float_division.input1 0.0
Divisor: storage large_number:math float_division.input2 0.0
Quotient: storage large_number:math float_division.output
```

♦ Divide a 12-digit 16-bit BCD array by a const (with 4 decimal): large_number:division/list_div_const

Principle: Long division

The fourth number in the output 16-bit BCD array will be a decimal, and the const cannot exceed five digits.

```
Input: 
Dividend: storage large_number:math list_div_const.dividend [I;0,0,0]
Divisor: #list_div_const_divisor int

Output: 
Quotient: storage large_number:math list_div_const.output
Quotient sign: storage large_number:math list_div_const.output_sign
```

♦ Division with an infinite number of significant digits: large_number:division/loop_more_more_decimal/start

```
Dividend
#float_sign int (Sign, options: -1, 0, 1, representing negative sign, zero, positive sign)
#float_int0 int (The first eight significant digits of the input value. Range is from 10000000 to 99999999 or 0)
#float_exp int (Exponent, range is a full int)

Divisor
#Divisor_float_sign int (Sign, options: -1, 0, 1, representing negative sign, zero, positive sign)
#Divisor_float_int0 int (The first eight significant digits of the input value. Range is from 10000000 to 99999999)
#Divisor_float_exp int (Exponent, range is a full int)

Number of significant digits: #loop_more_more_decimal_times int

Quotient
#float_sign int (Sign)
storage large_number:math loop_more_more_decimal_base (Base)
#float_exp int (Exponent)

The output base is a array, and the reading method involves writing each element from front to back, with a 0 added at the beginning. For example, if the values of #float_sign int and #float_exp int are 1 and 12 respectively, and the base is [0,0,1,9,0,3,7,0], then they represent the number 1*0.00190370*10^12.
```

♦ Taking the reciprocal of a floating-point number

8 decimal: large_number:division/float_reciprocal_8_dici/start

12 decimal: large_number:division/float_reciprocal/start

Input float or double

```
Input: storage large_number:math float_reciprocal.input 0.0
output: storage large_number:math float_reciprocal.output
```

　

♦ Int division

4 significant digits: large_number:division/int_4decimal/start

8 significant digits: large_number:division/int_8decimal/start

12 significant digits: large_number:division/int_12decimal/start

As a generalization of float division, although it accepts the entire int value, in practice, only the first eight digits of the dividend and divisor are considered.

```
Dividend: #int_+decimal.input1 int
Divisor: #int_+decimal.input2 int

Quotient: storage large_number:math int_more_decimal_out
```

♦ Array division by an int (multiple significant digits): large_number:division/list_div_int/start

The dividend must be a 16-bit BCD array, and all elements of the dividend array as well as the divisor must be positive.

Only the first eight digits of the divisor are considered. This algorithm has adaptive precision, and the dividend array does not need to input a full set of three numbers every time.

Principle: Segment division, (a+b+c)/m = a/m+b/m+c/m

No iteration, trial division, recursion, or variable number of commands.

```
Dividend: storage large_number:math list_div_int.list [I;0,0,0]
Divisor: storage large_number:math list_div_int.int 1

Quotient (double type): storage large_number:math list_div_int.output
```

　

♦ Arbitrary integer multiplication: large_number:int_mul_by_n/start

Principle: execute store + data get，It can be used to store integers using a multiplier and import dynamic multipliers using function macros.

```
Input integer: storage large_number:math int_mul_by_n.input_int
Input multiplier: storage large_number:math int_mul_by_n.input_n
The desired output data type: storage large_number:math int_mul_by_n.data_type "double"

output: storage large_number:math int_mul_by_n.output
```
The "integer" input can be a non-integer, but it will be processed as an integer by rounding down and limiting the range to the integer type. The "multiplier" input can be any numerical value, but the unit of data will be ignored during computation and converted into a double type. Optional data types: "byte"、"float"、"double"、"short"、"int"、"long".

　

♦ Float multiply

Algorithm1: large_number:float_multiply/start

Principle: execute store + data get，It can be used to store integers using a multiplier and import dynamic multipliers using function macros.

Algorithm2: large_number:float_multiply/of_score/start

Principle: Convert float to scoreboard format and take the first eight digits for large number multiplication.

```
Factor1: storage large_number:math float_multiply.input1 0.0
Factor2: storage large_number:math float_multiply.input2 0.0
Input float or double.

Product: storage large_number:math float_multiply.output
```

　

♦ High-precision float multiply: large_number:float_mul.high_precision/start

Principle: A new architecture is adopted, which converts all input values into arrays using the algorithm of converting double to int arrays, and then performs large number multiplication. The exponent is calculated based on the information read from the input values.

It can be accurate up to the level of double type.

```
Factor1: storage large_number:math float_multiply.input1 0.0
Factor2: storage large_number:math float_multiply.input2 0.0
Input float or double.

Product: storage large_number:math float_multiply.output
```

♦ High-precision float square：large_number:float_mul.high_precision/squ/start

```
Input：storage large_number:math float_multiply.input1 0.0
Input float or double

Output：storage large_number:math float_multiply.output
```

♦ High-precision float cube：large_number:float_mul.high_precision/cube/start

```
Input：storage large_number:math float_multiply.input1 0.0
Input float or double

Output：storage large_number:math float_multiply.output
```

　

♦ Float addition and subtraction: `execute in minecraft: overworld run function large_number:float_add_subtra/start`

Input float or double, but the output is always of double type.

Principle: execute positioned + loot spawn, input parameters using function macros. Since "loot spawn" has no coordinate upper or lower limits, this algorithm can perform addition and subtraction of all floating-point numbers.

```
Input: 
storage large_number:math float_add_subtra.input1 0.0
storage large_number:math float_add_subtra.input2 0.0

Operation mode: set #float_add_subtra_ope_mode int
1 stands for addition, and 2 stands for subtraction.
If it is addition, it is the sum of the two numbers. If it is subtraction, it is input1 minus input2

Output: storage large_number:math float_add_subtra.output
```

　

♦ Floating point number comparison：large_number:float_comparison_sizes/start

Subtract the input values using floating-point subtraction and determine the sign of the output.

```
Input：
storage large_number:math float_comparison_sizes.A 0.0
storage large_number:math float_comparison_sizes.B 0.0

Output comparison result：storage large_number:math float_comparison_sizes.output
"A" compared to "B", "+" indicates A is greater, "-" indicates A is smaller, "=" indicates they are equal.
```

♦ Round floating-point numbers：large_number:round_double/start

The command `execute align` and entity pos can only handle numbers in the range (-30,000,000.0, 30,000,000.0). This algorithm, however, uses function macros and string recursion to locate the decimal point and can handle all floating-point numbers.

```
Input：storage large_number:math round_double.input 1.0
Input float or double

Round towards zero：set #round_towards_zero int 1
If this value is not 1, rounding will be down; the default is rounding down.

Output：storage large_number:math round_double.output
```

♦ Perform decimal shifting on floating-point numbers：large_number:double_displacement/decimal.start

```
Input：storage large_number:math double_displacement.input 1.0
Input float or double

Number of shifts：storage large_number:math double_displacement.shift 2
Input int

Output：storage large_number:math double_displacement.output
```

　

♦ Int multiply: large_number:int_int_multiply

Principle: Array multiplication using vertical multiplication method.

```
Factor1: input int
Factor2: input.2 int
Product: storage large_number:math int_int_multiply.output
```

♦ Int square: large_number:int_square

```
Input: input int
Output: storage large_number:math int_squ
```

♦ 12 digits number multiply: large_number:1we_multiply

```
Factor1: storage large_number:math 1we_multiply.input1 [I;0,0,0]
Factor2: storage large_number:math 1we_multiply.input2 [I;0,0,0]
Product: storage large_number:math 1we_multiply.output
```

♦ 12 digits number square: large_number:1we_square

```
Input: storage large_number:math 1we_squ.input [I;0,0,0]
Output: storage large_number:math 1we_squ.output
```

♦ Infinite digit number multiply: large_number:infinite_digit_multiply/start

```
Factor1: storage large_number:math Infinite_digit_multiply.input1 [I;0,0]
Factor2: storage large_number:math Infinite_digit_multiply.input2 [I;0,0]
Input format: The factor must be a 16-bit BCD array, and all elements of the array must be positive.

output: storage large_number:math Infinite_digit_multiply.output
```

　

♦ Splitting an int into an array: large_number:cut_math_to_list

```
Input: input int
output: #sign int (Sign)，#1st int，#2nd int，#3rd int
```

　

♦ Int sqrt

Floor (16 pure scoreboard commands): large_number:int_sqrt_simple

4 decimals (32 pure scoreboard commands): large_number:int_sqrt

Retain multiple decimals: large_number:test_int_more_decimal

If the input value is 1 to 5 digits, output 9 decimal places; if the input value is 6 to 7 digits, output 8 decimal places; if the input value is 8 to 10 digits, output 7 decimal places.

Sometimes there may be a slight loss of precision in the last decimal digit obtained.

If the retained decimal places are not sufficient for the expected number of digits, leading zeros should be added to complete the number when reading.

Principle: Initial estimation + Newton iteration, see reference for details.

```
Input: input.sqrt int

Floor output: output.sqrt int
4 decimals output (Increase by a factor of ten thousand): output.sqrt int

Retain multiple decimals output: 
Integer part: output.sqrt int
Decimal part: output.decimal int
```

♦ Int sqrt - Continued Fraction Iteration Method: large_number:sqrt_continued_fraction/start

Accuracy can reach 14 decimal places.

The decimal part of the continued fraction iteration method is output in the form of a fraction.

Built-in overflow check, it automatically stops before overflowing in either the numerator or denominator.

For example, when calculating the square root of 10, the output after 50 iterations is the same as after 11 iterations.

Since both the numerator and the denominator are stored in single segments of the scoreboard, the actual allowable number of iterations should not exceed 32.

It is recommended to have an understanding of what a continued fraction is before use.

For the algorithm to generate continued fractions, please refer to the cited literature.

Continued fraction square root formula：

$$
\sqrt{x}\ =\cfrac{x-\left\lfloor\sqrt{x}\right\rfloor^2}{2\left\lfloor\sqrt{x}\right\rfloor+\cfrac{x-\left\lfloor\sqrt{x}\right\rfloor^2}{2\left\lfloor\sqrt{x}\right\rfloor+\cfrac{x-\left\lfloor\sqrt{x}\right\rfloor^2}{2\left\lfloor\sqrt{x}\right\rfloor+...}}}
$$

This is an infinite continued fraction, where increasing the number of terms brings the result closer to the actual value.

```
The number to be square rooted: #conti_frac.sqrt.input int
Iteration count: #conti_frac.sqrt.loops int
Simplification: set #conti_frac.sqrt.reduction_fraction int 1
Display continued fraction expression: set #conti_frac.sqrt.tellraw int 1

Output: 
Integer part: #conti_frac.sqrt.inte int

Decimal partv (fraction): 
Numerator: #conti_frac.sqrt.A int
Denominator: #conti_frac.sqrt.N int

Continued fraction expression: storage large_number:math conti_frac_sqrt_expression
```

♦ Int sqrt - Newton iteration (retain 4 decimals): large_number:newton.s_method_sqrt/int_decimal.4

The idea is to divide by a constant using an array, without trial division, recursion, or binary tree, utilizing 41 pure scoreboard commands.

```
Input: #Newton's-method_sqrt.input int
Output (Increase by a factor of ten thousand): #Newton's-method_sqrt.output int
```

♦ Sqrt of a 10 to 16 digit number

Principle: High-precision estimation method. Only the first eight digits are considered when calculating the first four digits of the square root. The remaining digits of the result are calculated using an estimation algorithm for decimals.

Floor: large_number:large_sqrt_digit16

Estimation method for decimals: large_number:large_sqrt_digit16_with_decimal

Long division method for decimals: large_number:large_sqrt_digit16_vertical_method

```
Input: storage large_number:math large_sqrt_digit16.input [I;0,0,0,0]

High-precision mode: set #large_sqrt16.test16 int 1

Output: 
Integer part: storage large_number:math large_sqrt_digit16.output
Decimal partv: storage large_number:math large_sqrt_digit16.output_decimal
Merge the integer and decimal parts: storage large_number:math large_sqrt_digit16.output_with_decimal
```

The high-precision mode is a feature of the 16-digit integer square root algorithm. In order to pursue efficiency, a high-precision estimation method is used, at the cost of a slight loss of precision in the last digit. This characteristic only occurs when dealing with 16-digit numbers.

In the high-precision mode, the algorithm validates its result by comparing the square of the calculated square root to the original number, for yourself decides whether to open it. The estimation method for decimals defaults to enabling the high-precision mode.

The long division method for decimals adopts an approach to square root extraction without precision fluctuations, but it can only extract four decimal places.

♦ Sqrt of a 1 to 24 digit number (floor): large_number:large_sqrt

Principle: Newton iteration+long division method

```
Input: storage large_number:math large_sqrt.input [I;0,0,0,0,0,0]
Output: storage large_number:math large_sqrt.output
```

To avoid wasting computing resources, please use the following priorities: Choose "Int sqrt" for numbers within the integer range, select "Sqrt of a 10 to 16 digit number" for 10 to 16 digit numbers, and consider "Sqrt of a 1 to 24 digit number" as a last resort.

　

♦ Cube root of an int

Principle: Cube root estimation algorithm. Take a constant x, where n is the integer part of the cube root of x, and z is the decimal part of the cube root. Then, (x-n\^3)/(3n\^2 +3n+1)≈z. The integer part is obtained using binary search.

Floor: large_number:cube_root/floor

Keep 4 decimal places: large_number:cube_root/4decimal

```
Input: #cbrt.input int
Output: #cbrt.output int
If four decimal places are to be retained, the output be multiplied by ten thousand.
```

　

♦ Euclidean norm of a double

The input data type must be double and only positive values are accepted.

1.Two-dimensional norm

Trigonometric method: `execute in minecraft: overworld as b09e-44-fded-6-efa5ffffef64 run function large_number:double_norm/trif_2d`

Formula: `√(x²+y²)=x/cos(atan2(y,x))`

Unit vector method: `execute in minecraft: overworld as b09e-44-fded-6-efa5ffffef64 run function large_number:double_norm/unit_vector_2d`

```
Input: 
storage large_number:math double_norm_2d.x 1.0d
storage large_number:math double_norm_2d.y 1.0d

Output: storage large_number:math double_norm_2d.output
```

2.Three-dimensional norm

Trigonometric method: `execute in minecraft: overworld as b09e-44-fded-6-efa5ffffef64 run function large_number:double_norm/trif_3d`

Formula: `√(x²+y²+z²)=λ/cos(atan2(z,λ))`，where λ is the two-dimensional norm with respect to x and y.

Unit vector method: `execute in minecraft: overworld as b09e-44-fded-6-efa5ffffef64 run function large_number:double_norm/unit_vector_3d`

```
Input: 
storage large_number:math double_norm_3d.x 1.0d
storage large_number:math double_norm_3d.y 1.0d
storage large_number:math double_norm_3d.z 1.0d

Output: storage large_number:math double_norm_3d.output
```

　

♦ Double to int - 16-bit BCD array format, precision of 16 significant digits：large_number:double_to_int

Input double or float

```
Input：storage large_number:math double_to_int.input 0.0d
Output：storage large_number:math double_to_int.output
```

Parameter Introduction:

- `math` is the mantissa, a 16-bit int decimal array.
- `sign` is the sign, a byte type, with values 1 or -1.
- `expon` is the exponent, a short type.

Reading Method:

The number is read in the form of S*0.AEB, where S is the sign, A is the mantissa, and B is the exponent.

Example:

`{sign:1b, math:[I;1623,13,3007,6000], expon:2s}` represents the number `1*0.1623001330076000*10^2`, which is `16.23001330076`.

　

♦ Note: SNBT Floating-Point Number Rules

For each number, there is always a sign and a value. In MC's floating-point numbers, the exponent, decimal point position, and leading zero count do not change simultaneously. If one of them changes, the other two parameters will be fixed values. In other words, for the converted number information:

- If the exponent is not 0, the decimal point position will definitely be 2 (after the first number), and the number of leading zeros will be 0.
- SNBT's floating-point integer part will display in scientific notation if it reaches 8 digits or if there are more than 3 leading zeros in the decimal part.
- If the decimal point position is not 2, the exponent will definitely be 0, and the number of leading zeros will be 0.
- If the number of leading zeros is between 1 and 3 (MC floating-point numbers can have up to three leading zeros), the decimal point position will definitely be 2, and the exponent will be 0.

Additionally, SNBT floating-point numbers can also be input in scientific notation, such as `1.2E3d`, and must include a data unit when using scientific notation.

The precise value of the "double" upper and lower limits is ±1.797693134862315807E308

The minimum absolute value of "double" is 4.9E-324

　

♦ Double to int - scoreboard format, precision of 8 significant digits

Macro Command Data Retrieval Method：large_number:float_nbt_to_score

Quadtree Data Retrieval Method：large_number:float_nbt_to_score/start

```
Input：storage large_number:math float_nbt_to_score_input 0.0

Output：
Sign：#float_sign int
Fraction：#float_int0 int
Exponent：#float_exp int

Example：
#float_sign int 1
#float_int0 int 44553375
#float_exp int 23
The represented number is: 1*0.44553375*10^23

The converted fraction is always eight digits.
```

　

♦ double sqrt (high-precision floating-point numbers sqrt)

Input double or float

8\~9 length number：large_number:double_sqrt

12\~14length number：large_number:double_sqrt_more_decimal

Using a 24-bit "16-bit BCD array" for root extraction, 12 significant digits of the square root of a double were obtained.

The number of commands for "8\~9 significant digits" is approximately 180, while for "12\~14 significant digits," it is about 1430, which is roughly 8 times the consumption of the former.

```
Input：storage large_number:math double_sqrt.input 0.0d
Output：storage large_number:math double_sqrt.output
```

　

♦ Fast floating-point square root: large_number:new_double_ope/double_sqrt_sci

The new architecture sacrifices a bit of accuracy and adopts a more efficient algorithm. 59 basic commands, plus 12 if the input is in scientific notation, plus 9 if the precision is increased by four digits, up to a maximum of 80 commands.

Principle: Using the magnification storage method to obtain the base of the double, using the string extraction method to obtain the exponent. The result is calculated using integer square root method, and the output is adjusted based on the exponent.

```
Input: storage large_number:math double_sqrt.input
Input double or float.
Increase precision by four digits: set #New_double_sqrt.decimal_add int 1

Output: storage large_number:math double_sqrt.output
```

　

♦ Display of a 24-digit number

Display the number of digits entered: large_number:digital_display

Always ensure that the displayed number is 24 digits long: large_number:24_digital_display

Difference: The latter automatically adds leading zeros to make the number 24 digits long if the input number is less than 24 digits.

Separate every three digits with a comma. If any number in the array is negative, consider the entire array as negative.

```
Input (16-bit BCD array): storage large_number:math math_display [I;0,0,0,0,0,0]

Displaying the following JSON text will show the numbers: 
[{"nbt": "math_display_json_is-","storage": "large_number:math"},{"nbt": "math_display_json[]","storage": "large_number:math","separator": {"text": ","}}]
```

　

♦ Distance measurement using unit vector method

1.Enter any two points: large_number:unit_vector_for_distance
Range of the difference between the coordinates of two points: 100\*|x|+100\*|y|+100\*|z| ≤2147483

```
Input
P1: storage large_number:math unit_vector2.P1 [0.0,0.0,0.0]
P2: storage large_number:math unit_vector2.P2 [0.0,0.0,0.0]
Operation: as b09e-44-fded-6-efa5ffffef64 run func...
Output (already magnified by 10 times): #distance int
```

2.Enter the absolute difference of the coordinates of the two points: large_number:unit_vector_for_distance_modu

Players need to calculate and enter the difference themselves.

Input value range: 100x+100y+100z ≤2147483

```
Input: storage large_number:math unit_vector_modu.input [0.0,0.0,0.0]
Operation: as b09e-44-fded-6-efa5ffffef64 run func...
Output (already magnified by 10 times): #distance int
```

♦ Triangular function method for rapid distance measurement：large_number:fast_distance_trigonometry/start

From：https://github.com/SuperSwordTW/Distance-Trig-Calc-3d

```
Input：#dx int，#dy int，#dz int
dy和dz值必须为正数

Output (Magnify by 1000 times)：#distance int
```

　

♦ List Algorithm - Shuffle: large_number:list_operation/shuffle/start

Randomly shuffle the order of a list.

Principle: @e[sort=random]

```
Input: storage large_number:math list_ope_shuffle.input []
Output: storage large_number:math list_ope_shuffle.output

Clean up temp markers generated by the list algorithm: 
execute in minecraft: overworld run kill @e[type=minecraft: marker,tag=large_number.list_operation]
```

♦ List Algorithm - Draw a Card: large_number:list_operation/random_index_once/start

Randomly draw an element from a list.

The length of the list cannot exceed 2147483583.

```
Input: storage large_number:math list_ope_random_index_once.input []
Remove the drawn item from the original list: set #list_ope_random_index_once.del int 1

Output: storage large_number:math list_ope_random_index_once.output
```

♦ List Algorithm - Deduplicate Elements (Return Value Method): large_number:list_operation/deduplicate/start

```
Input: storage large_number:math list_dedup.input []
Output: storage large_number:math list_dedup.output
```

　

♦ Convert UUID array to hyphenated hexadecimal format: large_number:uuid_list_for_hyphen/start

For example: [I; 30583058, 20172024, 31415926, -3059] to "01d2a912-0133-ccf8-01df-5e76fffff40d"

```
Input: storage large_number:math uuid_list_for_hyphen.input [I;0,0,0,0]
Output: storage large_number:math uuid_list_for_hyphen.output
```

♦ Convert hyphenated hexadecimal UUID to array: large_number:uuid_list_for_hyphen/back

For example: "00000035-ffff-f910-0000-00fffffffffd" to [I; 53, -1776, 255, -3]

The complete 32-bit UUID must be entered, and the 0 in front of each section cannot be omitted. The hexadecimal UUID has a total of 32 digits, with the number of characters in each section fixed at 8, 4, 4, 4, and 12.

```
Input: storage large_number:math uuid_hyphen_back_list.input ""
Output: storage large_number:math uuid_hyphen_back_list.output
```

　

♦ Random Number Generation - Binomial Distribution

Test 1: large_number:random/binomial_distribution/test1

Test Content: If the input values contain powers of 2, there is a 50% chance of subtracting the power of 2. Perform the test 31 times from 2^30 to 2^0 and return the modified input values.

```
Input (Only positive values are accepted): set #binomial_distribution.test1.input int
Output: #binomial_distribution.test1.output int
```

Test 2: large_number:random/binomial_distribution/test2

Test Content: Perform "n" trials of Bernoulli experiments with a success probability of "p", output the number of successful trials.

```
Number of Trials [int]: storage large_number:math binomial_distribution.n
success probability [float]: storage large_number:math binomial_distribution.p

Output [int]: storage large_number:math binomial_distribution.output
```

When n is large enough, the result approaches a normal distribution. The approximation works better when n is larger (at least 20) and p is not close to 0 or 1. Different empirical rules can be used to determine if n is large enough and if p is sufficiently far from 0 or 1. One commonly used rule is that both np and n(1-p) must be greater than 5.

♦ Random Number Generation - Normal Distribution: large_number:random/normal_distribution/test1/start

Test Content: Input an upper limit value n. Generate a random int32 number and repeatedly check its sign and multiply it by 2. If the number of times it is multiplied by 2 reaches 32, generate another random number and continue this operation until the number of checks reaches n. Then sum the results of the checks (0 or 1), and the result will approximate a normal distribution between 0 and n.

```
Upper Limit Value: set #normal_distribution.input int
Output: #normal_distribution.output int
```

♦ Random Number Generation - Uniform Distribution (PCG Algorithm)

This module is taken from the NTRE datapack written by xwjcool.

It uses the PCG algorithm, which is more elegant than the LCG algorithm provided by Java.

The random range is -2147483648..2147483647.

Select an entity A for generating random numbers: 

```
Init: as <entity A> run func ntre: randomize
Note: Each entity only needs to be init once when loading the datapack.

Generate Random Numbers: as <entity A> run func ntre: next
The output results are stored on the ntre_output scoreboard of entity A.
```

♦ Random Number Generation - Hypergeometric Distribution: large_number:random/hypergeometric_distribution/start

Test content: Drawing n objects without replacement from a finite set of N objects, which contains M specified types of objects, and counting the number of times that the specified type of object is successfully drawn.

```
Sample Pool: storage large_number:math hypergeometric_distribution_list [1,2]
Must input a list of positive integers. The elements in the input list are automatically assigned IDs based on their positions. For example, the ID of the first element is 1, and the ID of the fifth element is 5. Each number represents the quantity of the element with that ID.
ID of the elements to be drawn: #hypergeometric_distribution.target int
Number of draws: #hypergeometric_distribution.times int

Output: #hypergeometric_distribution.output int

Clean up temp markers generated during testing: 
execute in minecraft: overworld run kill @e[type=minecraft: marker,tag=large_number.list_operation]
```

♦ Generate a random number in the [0,1] range

PCG algorithm：`execute as b09e-44-fded-6-efa5ffffef64 run function large_number:random/number_0_1/start`

LCG algorithm：`execute as 3faf-0-3d00-0-61900f4241f run function large_number:random/number_0_1/lcg`

```
Output：storage large_number:math random_number_0_1
```

　

♦ Exponential Function

1. e^x : large_number:exp_e.x/start

e is the base of the natural logarithm, it is an irrational number, e ≈ 2.718281828459045.

Example: Input 4.231123, output 68.79444497242804

```
Preload library required: function large_number:exp_e.x/database
Unload preload library: data remove storage large_number:exp database

Input: storage large_number:math exp_e^x.input 2.0d
The input value must be of type double
Input range is within the interval: (-709, 709.7828)

Output: storage large_number:math exp_e^x.output
```

2. Arbitrary Power of a Positive Number: large_number:exp_any/start

Principle: : `a^b = e^(b*ln(a))`

Example: Input 5.7322^2.1123，output 39.976065

Exponent value distance：[0, 2147483647]

```
Preload lib for e^x: function large_number:exp_e.x/database
Initial database for ln[1,2]: function large_number:ln_high_precision/database
Unload initial database for: data remove storage large_number:ln_const database

Input: 
Base: storage large_number:math exp_any.input.base 2.0d
Exponent: storage large_number:math exp_any.input.expon 3.0d
The input value must be of type double

Output: storage large_number:math exp_any.output
```

3. n-th Root：large_number:exp_any/n_root

Formula：`a^(1/b) = e^(ln(a)/b)`

```
Preload lib for e^x：function large_number:exp_e.x/database

Input：
base：storage large_number:math exp_any.input.base 2.0d
exponent：storage large_number:math exp_any.input.expon 3.0d
Input values must be of type double. The base supports only positive numbers, while the exponent supports full double.

Output：storage large_number:math exp_any.output
```

♦ Int Exponentiation: large_number:int_base_int_power/start

Can calculate negative base or negative exponent.

Exponent value distance：[-2147483647, 2147483647]

Recursive multiplication method

```
Input: 
Base: #int_base_int_power.base int
Exponent: #int_base_int_power.expon int

Output: storage large_number:math int_base_int_power_out
```

♦ Exponentiation of Floating-Point Numbers: large_number:float_base_int_power/start

Recursive multiplication method

input value can be negative

Exponent value distance：[-2147483647, 2147483647]

```
Input: 
Base: storage large_number:math float_base_int_power.base 0.0
Exponent: storage large_number:math float_base_int_power.expon 0

Output: storage large_number:math float_base_int_power.output
```

♦ Integer Powers of Floating-Point Numbers - Fast Exponentiation：large_number:float_base_int_power/fast_power/start

The fast exponentiation algorithm is stable in performance. Regardless of how large the exponent is, it uses at most 30 floating-point multiplications and 30 floating-point squarings, which is significantly better than the recursive multiplication method.

Principle of the Fast Exponentiation Algorithm：https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E5%B9%82

```
Input: 
Base: storage large_number:math float_base_int_power.base 0.0
Exponent: storage large_number:math float_base_int_power.expon 0

Output: storage large_number:math float_base_int_power.output
```

　

♦ Int natural logarithm  ln(x): large_number:ln/start

Precision: The error should not exceed 0.0009, and return the result with the first four decimal places.

```
Loading initial database is required before performing calculations: function large_number:ln/ln_database

Input: #ln(x) int
Output (Increase by a factor of ten thousand): #ln(x).output int
Double output: storage large_number:math ln_output

Unloading initial database: function large_number:ln/uninstall_ln_database
```

♦ Double natural logarithm  ln(x): large_number:ln_double/start

Logarithmic formula: `ln(7.25)=ln(725/100)=ln(725)-ln(100)`，`ln(7.45*10^26)=ln(7.45)+26*ln(10)`

Return the result with the first four decimal places.

```
Loading initial database: function large_number:ln/ln_database

Input: storage large_number:math ln_double.input 0.0d
Output (Increase by a factor of ten thousand): #ln_double.output int
Double output: storage large_number:math ln_double.output
```

♦ Int logarithm  log.a(b): large_number:loga.b/start

Return the result with the first four decimal places.

Change of base formula: `log.a(b)=ln(b)/ln(a)`

Special cases: 

The logarithm of a number that is not 1 with a base of 0 or 1 does not exist, therefore the output value is also non-existent. 

The logarithm of 1 with any base is always 0. 

The logarithm of 0 with a base other than 0 or 1 is negative infinity, therefore the output double value is negative infinity, and the scoreboard value is -2147483648.

```
Loading initial database: function large_number:ln/ln_database

Input: 
base: #loga.b_a int
antilogarithm: #loga.b_b int

Output (Increase by a factor of ten thousand): #loga.b.output int
Double output: storage large_number:math "log.a(b).output"
```

♦ Double logarithm  log.a(b): large_number:loga.b_double/start

```
Loading initial database: function large_number:ln/ln_database

Input: 
base: storage large_number:math log(a,b)_double.a 0.0
antilogarithm: storage large_number:math log(a,b)_double.b 0.0

Output: storage large_number:math log(a,b)_double.output
```

♦ Int common logarithm  lg(x): large_number:lg/start

Return the result with the first four decimal places.

Formula: `lg(x) = ln(x)/ln(10)`

```
Loading initial database: function large_number:ln/ln_database

Input: #lg(x) int

Output (Increase by a factor of ten thousand): #lg(x)_output int
Double output: storage large_number:math lg(x)_output
```

　

♦ High-Precision Natural Logarithm (Full Double)：large_number:ln_high_precision/start

This algorithm is based on：https://www.zhihu.com/question/333371020/answer/1686069171

The polynomial obtained from the Remiz algorithm plays a crucial role in error correction for high-precision natural logarithm calculations, with theoretical error as low as 2^-58.45.

This algorithm uses a large number of high-precision floating-point multiplications, making its computational cost approximately 60 times that of table lookup methods.

```
Input：storage large_number:math ln_high_precision.input 1.0
Input values must be of type double.

Output：storage large_number:math ln_high_precision.output
```

　

♦ Factorial of a natural number: large_number:gamma_function/fundamental_factorial/start

The input range is within the interval : [0,170]

For natural numbers in the interval [0, 12], output factorial values as type int. For natural numbers in the interval [13, 170], output factorial values as type double.

```
Input: #natural_num.factorial.input int
Output: storage large_number:math natural_num_factorial
```

♦ Double factorial of a natural number: large_number:gamma_function/fundamental_factorial/double_factorial

The input range is within the interval : [0,300]

Here, double factorial is defined in its original infinite product form.

For double factorial values of natural numbers in the interval [0, 19], output as type int. For double factorial values of natural numbers in the interval [20, 300], output as type double.

```
Input: #natural_num.double_factorial.inp int
Output: storage large_number:math natural_num_double_factorial
```

♦ Gamma function - Stirling formula: large_number:gamma_function/stirling/start

Stirling's Formula:

$$
\Gamma\left ( {x+1} \right )\sim \sqrt {2πx}\left ( {\frac {x} {\mathrm{e}}} \right )^{x}\left ( {1+\frac {0.0845072303119} {x}} \right )
$$

Approximation of Γ(x+1) in the interval (-1, 0.2216):

$$
\Gamma\left ( {x+1} \right )\sim\frac{1}{x+1}+\frac{25}{49}x
$$

The input range is the interval: (-1, 170.6271]

This calculates Γ(x+1), primarily used for computing the factorial of real numbers.

```
Pre-library for e^x: function large_number:exp_e.x/database
Initial database for ln[1,2]: function large_number:ln_high_precision/database
Unloading initial database for ln[1,2]: data remove storage large_number:ln_const database

Input: storage large_number:math gamma_function.input 0.0d
Input value must be of type double

Output: storage large_number:math gamma_function.output
```

♦ Gamma function - recurrence formula: large_number:gamma_function/recursion/start

Recurrence formula:

$$
\Gamma\left(x+1\right)=x\Gamma\left(x\right)=\Gamma\left(x+1-a\right)\cdot\prod_{n=1}^{a}x+1-n,\ a\in\mathbf{N}
$$

Note: Π represents the product symbol.The value of 'a' depends on which interval you want to constrain 'x' to.

The input range is within the interval : [0.001, 170.6026)

```
Loading pre-library: function large_number:gamma_function/recursion/database
Unloading pre-library: data remove storage large_number:math gamma_databse

Input: storage large_number:math gamma_function.input 0.0d
Input value must be of type double.

Output: storage large_number:math gamma_function.output
```

　

♦ LambertW function

LambertW(x)：large_number:lambertw/start

LambertW.(-1)(x)：large_number:lambertw/-1/start

LambertW(x) is the inverse function of x\*e\^x.

Formula1：`LambertW(x) ~ ln(x)-ln(ln(x))+ln(ln(x))/ln(x) x≥3`

Formula2：`LambertW(x) ~ ln(x+1)/1.3 0≤x≤3`

Formula3：`LambertW(x) ~ tan(3.365x)/3.2 (-1/e)≤x≤0`

Formula4：`LambertW.(-1)(x) ~ ln(-x)-ln(-ln(-x))+ln(-ln(-x))/ln(-x)`

Input range：

LambertW(x)：[-1/e, ∞)

LambertW.(-1) (x)：[-1/e, 0]

-1/e≈-0.3678794411714

Input values must be of double type.

```
Initial database loading required before calculation：function large_number:ln/ln_database

Input：storage large_number:math lambertw.input 1.0d
Output：storage large_number:math lambertw.output
```

　

♦ Inverse gamma function - F.K.Amenyou formula：large_number:inverse_gamma_function/start

This calculates the inverse function of Γ(x+1), which is finding x given the factorial of x.

The value of the gamma function Γ(x) is not a bijective relationship with x, thus requiring a restricted domain.

Taking the part where Γ(x+1) is greater than or equal to 0, it can be observed that this function segment has a minimum value λ, λ≈0.8856031944109.

Define a constant φ such that Γ(φ+1)=λ, φ≈0.4616321449684.

In the interval [φ, ∞), Γ(x+1) is strictly monotonic, so there exists an inverse function when x∈[φ, ∞).

Define the implicit x=Γ(y+1) (y≥λ), satisfying this relationship which is the positive real number inverse factorial function. It is called the inverse of Γ(x+1), with its domain being [λ, ∞).

F.K.Amenyou formula：

$$
\mathrm{Inverse}\ \Gamma\left ( {x+1} \right )\sim \frac {\ln {\left ( {\frac {x} {\sqrt {2π}}} \right )}} {\mathrm{LambertW}\left ( {\frac {\ln {\left ( {\frac {x} {\sqrt {2π}}} \right )}} {\mathrm{e}}} \right )}-\frac {1} {2}+\frac {1} {30x}
$$

Related papers：https://ir.lib.uwo.ca/etd/5365/，https://www.ams.org/journals/proc/2012-140-04/S0002-9939-2011-11023-2/

Approximation of "Inverse of Γ(x+1)" in the interval (𝜆, 1.13):

$$
\mathrm{Inverse}\ \Gamma\left ( {x+1} \right )\sim\arcsin\left ( 1.23099326x-2.08932555 \right ) +\frac{\pi }{2} +\varphi
$$

𝜑≈0.4616321449684，𝜆≈0.8856031944109

Input range：x≥𝜆

```
Initial database for ln[1,2]：function large_number:ln_high_precision/database

Input：storage large_number:math inverse_gamma_function.input 1.0d
Output：storage large_number:math inverse_gamma_function.output
```

　

♦ Convert direction to quaternion with four components (xyzw): large_number:quaternion/facing/2tostoxyzw

The direction to be converted must be passed in.

```
Execute: as b09e-44-fded-6-efa5ffffef64 run func...

Output: 
List: storage large_number:math xyzw
Scores: #qrot_x int, #qrot_y int, #qrot_z int, #qrot_w int
```

♦ Euler angles to quaternion: `execute in minecraft: overworld as b09e-44-fded-6-efa5ffffef64 run function large_number:quaternion/euler_angles_to_xyzw`

```
Input: storage large_number:math euler_angles_input [0.0,0.0,0.0]
1st is roll, 2nd is pitch, 3rt is yaw.

Output: storage large_number:math xyzw
```


♦ Convert execution direction to unit vector：large_number:quaternion/facing/facing_to_unit_vector

Requires input of execution direction

```
Execute：as b09e-44-fded-6-efa5ffffef64 run func...
Output：storage large_number:math unit_vector
```

♦ Convert roll angle to quaternion：`execute in minecraft:overworld as b09e-44-fded-6-efa5ffffef64 run function large_number:quaternion/euler_angles_roll`

```
Input：storage large_number:math euler_angles_roll 0.0
Output：storage large_number:math xyzw
```

　

♦ Convert local coordinates to relative coordinates

Method 1 (vector dot product)：large_number:uvw/uvwtoxyz

Requires input of execution direction, with the world entity as the executor

```
Input：#u int，#v int，#w int
Output (Enlarge by ten thousand times)：#x int，#y int，#z int
```

Method 2 (macro)：large_number:uvw/uvwtoxyz_2

Input execution coordinates, execution height (anchored eyes|feet), execution direction.

Requires the world entity as the executor

```
Input：#u int，#v int，#w int
Output：#vec_x int，#vec_y int，#vec_z int
```

♦ Convert relative coordinates to local coordinates

Method 1 (vector dot product)：large_number:uvw/xyztouvw

Requires input of execution direction, with the world entity as the executor

```
Input：#x int，#y int，#z int
Output (Enlarge by ten thousand times)：#u int，#v int，#w int
```

Method 2 (macro)：large_number:uvw/xyztouvw_2

Input execution coordinates, execution height (anchored eyes|feet), execution direction.

Requires the world entity as the executor

```
Input：#vec_x int，#vec_y int，#vec_z int
Output：#u int，#v int，#w int
```

　

♦ Solve a monic quadratic equation with integer coefficients: large_number:quadratic_equation/start

The equation must be input in general form, where "a", "b", "c" have absolute values that are preferably not greater than 20724. Zero-coefficient "a" is supported.

More accurate: the range of values for Δ (b²-4ac) is the entire integer range, that is, -2147483648 ≤ b²-4ac ≤ 2147483647.

Solve using formula method:

$$
x={-b\pm\sqrt{b^2-4ac}\over2a}
$$

```
Input: 
#X_squ_equ.a int
#X_squ_equ.b int
#X_squ_equ.c int

Output (Increase by a factor of ten thousand): 
#X_squ_equ.x1 int
#X_squ_equ.x2 int

Expression form (un-simplified): storage large_number:math quadratic_equation_out.expression
Double output: storage large_number:math quadratic_equation_out.double

Determine the number of real roots: #X_squ_equ.roots int

Display the results of solving the equation: set #X_squ_equ.tellraw int 1
Displaying this JSON text will show the results: 
[{"nbt": "quadratic_equation_out_json_tellraw.json1","storage": "large_number:math","interpret": true},{"nbt": "quadratic_equation_out_json_tellraw.json2","storage": "large_number:math","interpret": true}]
```

Note: 

1.If the equation has two distinct real roots, the scoreboard scores for x1 and x2 both exist, and the expression form and double form are both lists, where the first item corresponds to x1 and the second item corresponds to x2.

2.If the equation has two equal real roots, the scoreboard scores for x1 and x2 both exist and are equal, the expression form is a single string, and the double form is a single double value.

3.If the equation has no real roots, the scoreboard scores for x1 and x2 do not exist, and both the expression form and the double form do not exist. `storage large_number:math quadratic_equation_out` will be an empty compound tag.

　

♦ Get the current date and time: large_number:timestamp/start

This function requires an internet connection to use.

Principle: Decoding the Base64 in the head of a genuine player will yield a JSON object containing a Unix timestamp.

Since obtaining the Base64 in the player head requires waiting for block updates, decoding may have some delay.

Known bug: If no output is observed after execution, it means that the head skin has not been loaded correctly. Solution is to delay execution of this function by several ticks before executing it again.

If it passes, it means that the parsing is incorrect.: `execute unless data storage large_number:timestamp output_base64_json.timestamp`

```
To use this function, you need to load the prerequisite library: function large_number:timestamp/database
Unload the prerequisite library: function large_number:timestamp/uninstall_database

Output
Year: #timestamp_year int
Month: #timestamp_month int
Day: #timestamp_day int
Hour: #timestamp_Hour int
Minute: #timestamp_Minute int
Second: #timestamp_Second int

The number of digits for hour, minute, and second is always two
Hour: storage large_number:timestamp output_day_Hour
Minute: storage large_number:timestamp output_day_Minute
Second: storage large_number:timestamp output_day_Second

Displaying the following JSON text will show the time: 
{"nbt": "output_base64_json_tellraw","storage": "large_number:math","interpret": true}

Replace the genuine player ID: storage large_number:math player_head_cache_list ["<玩家名>","<玩家名>"]
Note: 
Multiple player names can be stored in the list, but only the first name in the list will be read.
Initial input of genuine player ID: ka__er
```

Because each genuine player name can only obtain two timestamps when entering a single-player archive/server, one when placed as a block and one when placed in an entity's inventory. Then the timestamp exists in the cache and is no longer updated. To update the timestamp, there are only three methods: 

1. Re-enter the archive/restart the server; 
2. The head cache expires automatically after one month; 
3. Replace with a new genuine player ID. 

Therefore, if you want to keep the server running for a long time, it is recommended to use internal timing with command blocks, synchronize the time once every two hours, and synchronize the date by replacing a new genuine player ID once every 24 hours. After 30 replacements, the head cache of the first used player ID will expire.

　

♦ Unix Timestamp Parser (32-bit): large_number:timestamp/parse_timestamp/start

```
Input (int or string): storage large_number:math parse_timestamp.input

Input GMT time zone: set #GMT-time_zone int 8
For example, Beijing time is GMT+8, so input 8, default is 8

Output: 
Year: #parse_timestamp.year int
Month: #parse_timestamp.month int
Day: #parse_timestamp.day int
Hour: #parse_timestamp.Hour int
Minute: #parse_timestamp.Minute int
Second: #parse_timestamp.Second int

Display the following JSON text to show the parsing result: 
{"nbt": "parse_timestamp.tellraw","storage": "large_number:math","interpret": true}
```

　

♦ Player Experience Formula - Calculate total experience based on experience level and experience points: large_number:xp_formula/levels_to_points/start

When the experience level is ≥32, the player's experience points are：

$$
f\left ( {x} \right )=1507+\sum ^{x-1}_{n=32} {9n-158}\ =\ 4.5{x}^{2}-162.5x+2099
$$

When the experience level is greater than or equal to 32, the player's experience is given by: f(x) = 1507+Σ(9n-158, n=32, x-1).

The output value generally cannot be directly used to reverse-engineer a player's existing experience level, due to some special algorithms within Minecraft. There may be some discrepancies between this value and the actual experience points the player has at the moment.

How much difference is there? For example, giving a player 1628 experience points with the "xp" command and giving them 1507 experience points once and 121 experience points once with the same command will result in a difference of 1 point in the total experience gained.

The reason for this is that Minecraft uses the XpP parameter from the player's NBT data when calculating the experience required for the player to level up. This parameter is a floating-point number stored as a percentage, and floating-point errors lead to slight discrepancies between the actual experience the player has and the theoretical experience amount.

```
Input: 
Levels: #xp_formula.levels int
Points: #xp_formula.points int
The points number can be obtained using /xp query @s points.

Output: storage large_number:math xp.output
```

♦ Player Experience Formula - Reverse calculation of experience level and experience remainder from total experience: large_number:xp_formula/points_ope_levels/start

Reverse Experience Formula: 

$$
g(x)={\sqrt{72x-45503}+325\over18}
$$

The experience formula is a quadratic equation. By using the quadratic formula to reverse it, and keeping only the roots where x ≥ 0, we obtain this reverse experience formula.

Theoretically, the input value should not exceed 2.07526 * 10^19.

```
Input: storage large_number:math xp_points_ope_levels.input [I;0,0,0,0,0]
This algorithm adapts to the number of digits automatically, so there's no need to input a full set of five numbers each time.

Output: 
Levels: storage large_number:math xp_points_ope_levels.output_levels
Points: storage large_number:math xp_points_ope_levels.remaining_points

If used to give experience to a player, the experience level should be given first, followed by the points remainder.
```

　

♦ RGB to hexadecimal conversion: large_number:rgb_to_hexadecimal/start

```
Input (The RGB values range from 0 to 255): 
#rgb_to_hexadecimal.R int
#rgb_to_hexadecimal.G int
#rgb_to_hexadecimal.B int

Output: storage large_number:math rgb_to_hexadecimal_output
```

　

♦ Sum of the first N terms of a harmonic series: large_number:harmonic_series/sum1-n

Approximation by formula, no recursion.

Formula: 

$$
H_{x}=\sum ^{x}_{n=1} {\frac {1} {n}}=\psi\left ( {x+1} \right )+\gamma\approx \ln {\left ( {x} \right )}+0.5772+\frac {0.4995078} {x}
$$

Note: Σ denotes the sum of a series, ψ represents the Digamma function, the natural logarithm derivative of the gamma function, γ is the Euler-Mascheroni constant, also known as the sum of Ramanujin of the harmonic series, approximately 0.5772156649.

When the input value is negative, the output is 5772, which is the sum of Ramanujin of the harmonic series.

```
Loading initial database: function large_number:ln/ln_database

Input: storage large_number:math Harmonic_series_sum_input 3.0
Input double, float or int, using double or float type inputs can calculate values beyond the int range.

Output (Increase by a factor of ten thousand): #Harmonic_series.sum.output int
```

　

♦ Int prime factorization: large_number:prime_factorization/start

```
Input: #prime_factorization.input int
Output: storage large_number:math prime_factorization_output

If the output list has only one item, then the input value is a prime number.
```

　

♦ Sigmoid(x)：large_number:sigmoid/start

Sigmoid(x)=1/(1+e^(-x))

This algorithm is based on：https://zhuanlan.zhihu.com/p/318423774

```
Input：storage large_number:math sigmoid.input 1.0
Output：storage large_number:math sigmoid.output
```

　

♦ Digamma(x)：large_number:digamma_function/start

Formula：`ψ(x)~ln(x)-1/(2x)`

if input value "1", output "-γ".

```
Initial database for ln(x)：function large_number:ln/ln_database

Input：storage large_number:math digamma_function.input 0.0
Input values must be of type double, and the input range is: x>0

Output：storage large_number:math digamma_function.output
```

　

♦ Int simplification：large_number:int_simplify/start

Accepts only positive numbers

```
Input1：#int_simplify.input1 int
Input2：#int_simplify.input2 int

Input value after simplification 1：#int_simplify.output1 int
Input value after simplification 2：#int_simplify.output2 int

Greatest common divisor of the two numbers：#int_simplify.greatest_common_divisor int
If the greatest common divisor is 1, the two numbers are coprime.
```

　

♦ Integer to binary conversion：large_number:convert_decimal_to_binary

Conversion according to the storage rules of 32-bit signed integers, output list consists of fixed 32 integers, each integer representing the binary number of that bit position; for negative numbers, two's complement is used.

```
Input：#convert_decimal_to_binary.input int
Output：storage large_number:math convert_decimal_to_binary_out

Display the following JSON text to show the output:
{"nbt":"convert_decimal_to_binary_out[]","storage":"large_number:math","separator":""}
```

　

♦ Integer Base Conversion

1. Decimal to Base 2–36：large_number:number_base_conversion/10_to_any

```
Input：#conversion.10_to_any.input int
Only positive numbers are accepted.

Base Radix：#conversion.10_to_any.radix int
Accepted base radices are from 2 to 36.

Output：storage large_number:math number_base_conversion
The output is a list where each item represents the digit in that base.
```

2. Base 2–36 to Decimal：large_number:number_base_conversion/any_to_10

```
Input：storage large_number:math number_base_conversion ["f","f","0","9","7"]

Base Radix：#conversion.10_to_any.radix int
Accepted base radices are from 2 to 36.

Output：#conversion.any_to_10.output int
```

　

♦ Expression evaluation - Arithmetic operations

Symbols accepted: `+－*/().E-`. To distinguish subtraction from negative numbers during the process of converting to Reverse Polish Notation, `－` (Full-width hyphen) represents subtraction and `-` (Half-width hyphen) represents negative numbers. Numbers can only be int or double. Double type numbers can be in scientific notation and do not need units; double type numbers can only use floating-point arithmetic.

Note: Do not place a single number in parentheses. If necessary, write it in the form (a+0). There is no rule in this algorithm that states "negative numbers must be placed in parentheses".

Reverse Polish Notation algorithm：https://blog.csdn.net/zm_miner/article/details/115324206

Conversion and computation completion both have prompts.

1.Convert the expression to Reverse Polish Notation：large_number:expression_evaluation/to_rev_polish_notation

```
Input：storage large_number:math expression_evaluation.input "(12+14)*(106－32)"
Output the converted Reverse Polish Notation (can be directly used for parsing and evaluation)：storage large_number:math expression_evaluation.rev_polish_notation
```

2.Parse Reverse Polish Notation

Evaluate using integer arithmetic：large_number:expression_evaluation/ope_of_inte

Evaluate using floating-point arithmetic：large_number:expression_evaluation/ope_of_float

```
Input Reverse Polish Notation：storage large_number:math expression_evaluation.rev_polish_notation ["51E-2","3","+"]
Output the calculation result：storage large_number:math expression_evaluation.output

Display Reverse Polish Notation (JSON text):
{"nbt":"expression_evaluation.rev_polish_notation[]","storage":"large_number:math","separator":" "}
```

　

♦ Expression Evaluation - Scientific Computing

Operators accepted: `+－*·/().E-^²` (addition, subtraction, multiplication, division, parentheses, decimal point, scientific notation, negation, exponentiation, square). `·` is equivalent to `*`.

For exponentiation, integer powers are recursively multiplied, while non-integer powers use a table lookup algorithm. For division, if the dividend is 1, a special reciprocal calculation is performed.

To differentiate subtraction from negative numbers in the conversion to Reverse Polish Notation, `－` (full-width minus sign) indicates subtraction, while `-` (half-width minus sign) indicates a negative number.

Numbers must be doubles, and units are not required.

Note: Do not place a single number in parentheses alone; use (a+0) instead if necessary. There is no rule in this algorithm that requires negative numbers to be in parentheses alone. Even when multiplying a variable and a number, the multiplication sign must be included.

Conversion and computation completion will be indicated.

Function List (34 functions supported):

> Each function and its parameters must be enclosed in separate parentheses, supporting composite functions.
>
> Parameters α, β, and δ should be enclosed in parentheses if they are not numbers. If they are numbers, they do not need to be in parentheses.
>
> For example, `sin7+2` should be written as "(sin7)+2", and `ln(2+9)·2-3` should be written as "(ln(2+9))·2－3".

```
Function names: exp; sin; cos; arcsin; arccos; arctan; ln; √; Γ; ┕; ºLambertW; ¹LambertW; ||; sgn; []; [0]; —; ψ; Σ[1/n]n→; log; atan; nroot; eunorm₂; eunorm₃; >=; <=; ==; ≈≈; >/<; >-<; >>; <<; ≥≥; ≤≤;

Introduction:

Unary Operations
expβ = e^β, exponential function, integer powers are recursively multiplied, non-integer powers use a table lookup.
sinβ = sin(β), in radians.
cosβ = cos(β), in radians.
arcsinβ = arcsin(β), in radians.
arccosβ = arccos(β), in radians.
arctanβ = arctan(β), in radians.
lnβ = ln(β), natural logarithm.
√β = √β, square root.
Γβ = Gamma function, gamma(β), input range: (0, 171.6271]. For integers, it's factorial; for non-integers, Stirling's formula.
┕β = Inverse Gamma function, inverse of Gamma(x) main branch, input range: β≥𝜆, 𝜆≈0.8856031944109.
ºLambertWβ = LambertWº(β), main branch, input range: [-1/e, ∞).
¹LambertWβ = LambertW¹(β), -1 branch, input range: [-1/e, 0).
||β = Absolute value of β.
sgnβ = sgn(β), sign function.
[]β = Floor of β.
[0]β = Round β towards zero.
—β = Half dash, represents the opposite of β. Note: This symbol is not equivalent to a minus sign; it represents the function of "taking the opposite.".
ψβ = ψ(β), digamma function, the logarithmic derivative of the Gamma function.
Σ[1/n]n→β = Sum of the first β terms of the harmonic series.

Binary Operations
αlogβ = Logarithm of β base α.
αatanβ = atan2(α, β), in radians.
αnrootβ = Taking the α-th root of β
αeunorm₂β = √(α²+β²), Euclidean norm of the 2D vector (α, β), both must be non-negative. Calculation method is the trigonometric method.
α>/<β = Swap division, β divided by α.
α>-<β = Swap subtraction, β minus α.

Logical operation
α>=β = returns the larger value.
α<=β = returns the smaller value.
α==β = strictly checks equality, returns 1 if equal, otherwise 0.
α>>β = whether α is greater than β
α<<β = whether α is less than β
α≥≥β = whether α is greater than or equal to β
α≤≤β = whether α is less than or equal to β
α≈≈β,δ = error checking, determines if the distance between α and β is within the absolute value of δ, returns 1 if true, otherwise 0. Note: Floating-point errors may cause inaccuracies, e.g., 0.02 might become 0.020000000000000018.

Ternary Operations
αeunorm₃β,δ = √(α²+β²+δ²), Euclidean norm of the 3D vector (α, β, δ), all must be non-negative. The comma here is a placeholder. Calculation method is the unit vector method.
```

Required Libraries:

```
Pre-library for e^x:
Load：function large_number:exp_e.x/database
Unload：data remove storage large_number:exp database

Initial database for ln:
Load：function large_number:ln/ln_database
Unload：function large_number:ln/uninstall_ln_database
```

1.Convert Expression to Reverse Polish Notation：large_number:expression_evaluation_scientific/to_rev_polish_notation

```
Input：storage large_number:math expression_evaluation.input "(12+14)*(106－32)"

Supports variable substitution; variables can be automatically interpreted as numbers from specified paths. Expressions with only variables can also be parsed, e.g., computing ["π"] outputs 3.141592653589793.

Supported variable names: α; β; δ; ε; η; λ; μ; ξ; τ; ω; ｘ; ｙ; ｚ
Here, ｘｙｚ are full-width letters corresponding to paths (target values must be floating-point numbers):
α：storage large_number:math expression_evaluation_variables."α"
β：storage large_number:math expression_evaluation_variables."β"
δ：storage large_number:math expression_evaluation_variables."δ"
ε：storage large_number:math expression_evaluation_variables."ε"
η：storage large_number:math expression_evaluation_variables."η"
λ：storage large_number:math expression_evaluation_variables."λ"
μ：storage large_number:math expression_evaluation_variables."μ"
ξ：storage large_number:math expression_evaluation_variables."ξ"
τ：storage large_number:math expression_evaluation_variables."τ"
ω：storage large_number:math expression_evaluation_variables."ω"
ｘ：storage large_number:math expression_evaluation_variables."ｘ"
ｙ：storage large_number:math expression_evaluation_variables."ｙ"
ｚ：storage large_number:math expression_evaluation_variables."ｚ"

Supports input of mathematical constants, automatically replaced with corresponding values: π, e, γ.
To differentiate, use full-width letter e.

Output Reverse Polish Notation (can be used directly for parsing and evaluation)：storage large_number:math expression_evaluation.rev_polish_notation
```

2.Parse Reverse Polish Notation：large_number:expression_evaluation_scientific/ope

The list has the functionality of extracting specific items by number, so non-binary operations can be defined using Reverse Polish Notation.

```
Input Reverse Polish Notation：storage large_number:math expression_evaluation.rev_polish_notation ["51E-2","3","+","ºcos"]
Output result：storage large_number:math expression_evaluation.output

Display Reverse Polish Notation (JSON text):
{"nbt":"expression_evaluation.rev_polish_notation[]","storage":"large_number:math","separator":" "}
```

　

♦ Definite Integrals

"Expression Evaluation - Scientific Computing" Extension

Uses the Riemann integral method by sampling at average distances within an interval and multiplying the sampled values by the width of the subinterval.

Only single integrals can be computed. The integrand must be "Riemann integrable" within the interval, and the result can only be a number (numerical integration, which cannot handle parameterized results).

The integrand is taken directly from the Reverse Polish Notation parsed by "Expression Evaluation - Scientific Computing," with the integration variable as x*x*.

Formula (Trapezoidal Rule):

$$
\int ^b_a {f(x)\ \mathrm{d}x\ \approx}\ \frac {b-a} {k}\left ( {\frac {f\left (a \right )+f\left (b \right )} {2}+\sum ^{k-1}_{n=1} {f\left ( {a+\frac {b-a} {k}n} \right )}} \right )
$$

where "k" is the number of small rectangles within the interval. The height of these small rectangles is the function value at the right end of the subinterval.

Integration over the [0,1] Interval：large_number:definite_integral/riemann_integral/0_1/start

Integration over Other Intervals：large_number:definite_integral/riemann_integral/start

Completion of the calculation will be indicated.

```
Integration Region Lower Bound (double)：storage large_number:math expression_evaluation.definite_integral.a 1.0
Integration Region Upper Bound (double)：storage large_number:math expression_evaluation.definite_integral.b 2.0
Number of Small Rectangles in the Interval (int)：storage large_number:math expression_evaluation.definite_integral.dx_times 200
Must be a positive integer, with an upper limit of 1,000,000,000. Generally, choose between 100 and 500.

Output：storage large_number:math expression_evaluation.definite_integral.output
If the path does not exist after the calculation, it indicates that the computation is too large, exceeding the single tick command execution capacity, and requires asynchronous computation.
```

　

♦ Curve Length - Length of the Graph of a Single Variable Function on [a,b]：large_number:curve_length/univariate_function/start

"Expression Evaluation - Scientific Computing" Extension

Uses a polyline fitting method and can only handle continuous functions.

The function expression is taken directly from the Reverse Polish Notation parsed by "Expression Evaluation - Scientific Computing."

```
Region Lower Bound (double)：storage large_number:math expression_evaluation.definite_integral.a 2.0
Region Upper Bound (double)：storage large_number:math expression_evaluation.definite_integral.b 3.0
Number of Samples in the Interval (int)：storage large_number:math expression_evaluation.definite_integral.dx_times 200
Must be a positive integer, with an upper limit of 1,000,000,000. Generally, choose between 100 and 500.

Output：storage large_number:math expression_evaluation.univariate_function_length
```

　

♦ Numerical Derivatives

Uses the finite difference method.

First Derivative Midpoint Formula:

$$
f'\left ( x_i \right )\approx\frac{f\left ( x_i+\Delta x \right )-f\left ( x_i-\Delta x \right )}{2\Delta x} 
$$

Second Derivative Formula:

$$
f''\left ( x_i \right )\approx\frac{f\left ( x_i+\Delta x \right )+f\left ( x_i-\Delta x \right )-2f\left ( x_i \right )}{\left(\Delta x\right)^2}
$$

The function to be differentiated is taken directly from the Reverse Polish Notation parsed by "Expression Evaluation - Scientific Computing."

First Derivative Value：large_number:differential/difference_quotient_method/1/start

Second Derivative Value：large_number:differential/difference_quotient_method/2/start

```
x Value at the Differentiation Point：storage large_number:math expression_evaluation.differential.input 1.0

Size of Δx：storage large_number:math expression_evaluation.differential.dx 0.04
Δx should be a small value within the range [1, 1E-9]. Due to floating-point errors, it should not be too small, typically chosen between 0.01 and 0.001.

First Derivative Value：storage large_number:math expression_evaluation.differential.1output
Second Derivative Value：storage large_number:math expression_evaluation.differential.2output
```

　

♦ Particle circle in any direction in three-dimensional space

```
Radius (1000 times the input): #3d.circle.r int
For example, entering 3000 corresponds to a radius of 3

Particle density: #3d.circle.angle int
Particle density refers to plotting a point every "n/10" degrees, where n ranges from 1 to 3600.

Calculate coordinates: 
execute as b09e-44-fded-6-efa5ffffef64 run function large_number:particle/3d_ar_rotation_circle/start

Output relative coordinate list: 
x: storage large_number:math 3d_ar_rotation_circle_posX
y: storage large_number:math 3d_ar_rotation_circle_posY

Display particles: 
execute positioned x y z rotated x y run function large_number:particle/3d_ar_rotation_circle/particle
The execution orientation corresponds to the direction of the circle, and the execution position corresponds to the center of the circle.
```

```
Dye the circle into a color ring: function large_number:particle/rainbow_circle/start

Output the list of colors: storage large_number:math rainbow_circle_color

Display the circle after dyeing: 
execute positioned x y z rotated x y run function large_number:particle/rainbow_circle/particle.macro1

You can achieve a rotating blinking effect like a neon light by rotating the color list. Here's an example: 
Initialize: 
data modify storage large_number:math rainbow_circle_color_list_rotate set from storage large_number:math rainbow_circle_color
Display particles: 
execute positioned x y z rotated x y run function large_number:particle/rainbow_circle/particle_list_rotate
```

♦ Five-pointed star in any direction in three-dimensional space

Both algorithms are derived from: https://www.bilibili.com/read/readlist/rl651851

Algorithm 1: Formula-Based Drawing

```
Radius (100 times the input): #3d.pentagram.r int
For example, entering 500 corresponds to a radius of 5

Particle density: #3d.pentagram.density int
Particle density refers to plotting a point every "n/10" degrees, where n ranges from 1 to 3600.

Roll degrees of the five-pointed star (1000 times the input): #3d.pentagram.roll.θ int

Calculate coordinates: 
execute as b09e-44-fded-6-efa5ffffef64 run function large_number:particle/3d_ar_rotation_pentagram/start
```

Algorithm 2: Cycloid Method Drawing

This method involves converting high-frequency armor frame rotations into function recursion.

```
Radius (10000 times the input)：#3d.pentagram_epi.r int

Rotation speed during cycloidal circular motion：#3d.pentagram_epi.speed int
Range: [1, 7200000]. Reference value: 20000 is moderate.
The number of function recursions is related to the rotation speed. To ensure a complete drawing, a slower rotation speed results in more particle coordinates, while a faster speed results in fewer coordinates. The maximum recursion count is given by 7200000 divided by the rotation speed.

Pentagram's roll angle (10000 times the input)：#3d.pentagram_epi.roll.θ int

Coordinate Calculation:
execute as b09e-44-fded-6-efa5ffffef64 run function large_number:particle/3d_ar_rotation_pentagram/epicycloid/start
```

Display the shape

```
Output a list of relative coordinates:
storage large_number:math 3d_ar_rotation_pentagram_pos
Each sublist contains: The first item is the x-coordinate, the second item is the y-coordinate.

Display particles:
execute positioned x y z rotated x y run function large_number:particle/3d_ar_rotation_pentagram/particle
The execution direction is the direction of the pentagram, the execution position is the position of the pentagram.
```

♦ Ellipse in any direction in three-dimensional space

```
100 times the input, a: #3d.ellipse.a int
100 times the input, b: #3d.ellipse.b int
The input, magnified by 1000, ranges from [1,2147483]

Particle density: #3d.ellipse.density int
Particle density refers to plotting a point every "n/10" degrees, where n ranges from 1 to 3600.

Roll angle (1000 times the input): #3d.ellipse.roll.θ int

Calculate coordinates: 
execute as b09e-44-fded-6-efa5ffffef64 run function large_number:particle/3d_ar_ellipse/start

Output relative coordinate list: storage large_number:math 3d_ar_ellipse_pos
Each sublist contains x as the first item and y as the second item.

Display particles: 
execute positioned x y z rotated x y run function large_number:particle/3d_ar_ellipse/particle
The execution orientation corresponds to the direction of the ellipse, and the execution position corresponds to the center of the ellipse.
```

♦ Particle sphere (Fibonacci grid)

Uniform Sampling Method on the Sphere: If n points are taken from the surface of the sphere, it involves slicing the sphere horizontally into n layers. These points then climb from the bottom to the top of the sphere along its surface. Each layer climbed corresponds to rotating 0.618 revolutions around the center of that layer.

Related links：https://zhuanlan.zhihu.com/p/25988652

```
Radius: storage large_number:math 3d_hsphere_pos_R 0.0

Number of points taken on the sphere's surface
Input range from [1,40000]

Calculate coordinates: 
execute as b09e-44-fded-6-efa5ffffef64 run function large_number:particle/3d_hsphere/start

Output relative coordinate list: storage large_number:math 3d_hsphere_pos
Each sublist contains an x as the first item, a y as the second item, and a z as the third item.

Display particles: 
execute positioned x y z rotated x y run function large_number:particle/3d_hsphere/particle/start
Pass in the execution position and execution orientation.
```

Additional commands can be executed on the points on the sphere's surface: 

```
Commands to be executed on the points on the sphere's surface: 
storage large_number:math 3d_block_hsphere_execute "setblock ~ ~ ~ glass"

Execute command: 
execute positioned x y z rotated x y run function large_number:particle/3d_block_hsphere/set/start
Pass in the execution position and execution orientation.
```

　

♦ Holographic Particle Projection - 16x16x16 projection to 1x1x1

Project colored concrete as dust particles.

After one scan, particle color, coordinates, and other information will be stored in the database, so projection is still possible even if the scan area is cleared.

Adding resolvable blocks: 

In the function "particle/holographic_projection/if" starting from line 18, add commands in the following format: `execute if block ~ ~ ~ xxx run data modify storage large_number:math temp_particle set value "<four special parameters of dust particles>"`

```
Scan: execute positioned x y z run function large_number:particle/holographic_projection/scan.start
Execution position needs to be at the northwest bottom corner of the scanning area.
When "全息粒子投影: 扫描完成！" appears in the chat, the scan is complete.

Projection: execute rotated 0.0 0.0 positioned x y z run function large_number:particle/holographic_projection/execute with storage large_number:math holographic_projection_database
Projection requires input of projection point and angle; the base point for displacement and rotation is at the center of the bottom of the projection.
Will trigger the function macro caching mechanism; can be executed at high frequency.

Clear database: data remove storage large_number:math holographic_projection_database
```

　

♦ Parabola

1.Parse the coordinates of three points into the abc of a quadratic function expression: large_number:parabola/3point_ope_coef.abc

Principle: Solve the system of three linear equations corresponding to the three points using addition-subtraction elimination method.

```
Input: storage large_number:math parabola_points [[0.0,0.0],[0.0,0.0],[0.0,0.0]]
Input two-dimensional coordinate points, with integers and the first decimal place.

Output (scaled by a factor of one thousand): #coef.a int，#coef.b int，#coef.c int
```

2.The expression of the quadratic function is analyzed for the relative coordinates of the points: large_number:parabola/analysis.start

Formula: `f(x)=ax²+bx+c`

The parsed coordinates will be stored in a list, no need to parse every time.

```
Input coefficients multiplied by one thousand: #coef.a int，#coef.b int，#coef.c int
Input starting X value multiplied by one hundred: #parabola_expre_x.start int
Input number of steps: #parabola_expre_x.length int
Input step size multiplied by one hundred: #parabola_expre_x.step_size int

Output list of relative coordinates: 
x: storage large_number:math parabola_expre_x
y: storage large_number:math parabola_expre_y

Display the parabola expression: set #parabola_.tellraw int 1
The following JSON text can be used to display the parabola expression: 
["f(x)=",{"nbt": "parabola_tellraw.a","storage": "large_number:math"},"x²",{"nbt": "parabola_tellraw.1","storage": "large_number:math"},{"nbt": "parabola_tellraw.b","storage": "large_number:math"},"x",{"nbt": "parabola_tellraw.2","storage": "large_number:math"},{"nbt": "parabola_tellraw.c","storage": "large_number:math"}]
```

3.Display the trajectory of the parabola: `execute positioned x y z rotated 0.0 0.0 run function large_number:parabola/particle`

Pass in the execution position and execution orientation.

```
Mode: #parabola_expr_particl_mode int
Choose between 1 or 2; the difference lies in the reference frame of the particles, which can accommodate different rotation requirements.
In Mode 1, particles originate from the left direction of execution; in Mode 2, particles originate from the front direction of execution.

The displacement and rotation base point of the parabola is its starting point.
```

　

♦ Archimedean Spiral (Constant-Speed Spiral)

Formula: `r=a+bθ`

```
Input a multiplied by one thousand: #archimedean_spiral.a int
Input b multiplied by one thousand: #archimedean_spiral.b int
Input starting degrees multiplied by one hundred: #archimedean_spiral.startθ int
Input arc length step size multiplied by one hundred: #archimedean_spiral.arc_size int
Input degrees step size multiplied by one hundred.: #archimedean_spiral.θ_size int
Number of steps: #archimedean_spiral.length int
Use arc length to calculate the interval between points after n steps: #archimedean_spiral.to_arc int

Calculate coordinates: function large_number:particle/archimedean_spiral/start

Output relative coordinate list: 
x: storage large_number:math archimedean_spiral_out_listX
y: storage large_number:math archimedean_spiral_out_listY

Display particles: 
execute positioned x y z rotated x y run function large_number:particle/archimedean_spiral/particle
Pass in the execution position and execution orientation.
```

A preset: a is 100, b is 8, starting angle is 0, arc length step is 35, angle step size is 1000, use arc length after 30 steps.

　

♦ Equiangular Spiral (Logarithmic Spiral)

Formula: `θ=a*ln(b*r)`

```
Loading initial database: function large_number:ln/ln_database

a: #equiangular_spiral.a int
b: #equiangular_spiral.b int
Input initial radius multiplied by one thousand: #equiangular_spiral.start_r int
Input radius step multiplied by one thousand: #equiangular_spiral.r_size int
Number of steps: #equiangular_spiral.length int

Calculate coordinates: function large_number:particle/equiangular_spiral/start

Output relative coordinate list: 
x: storage large_number:math equiangular_spiral_out_listX
y: storage large_number:math equiangular_spiral_out_listY

Display particles: 
execute positioned x y z rotated x y run function large_number:particle/equiangular_spiral/particle
Pass in the execution position and execution orientation.
```

A preset: the "a" is 5000, the "b" is 560, the "initial radius" is 0, the "radius step" is 50, and the "number of steps" is 250.

　

♦ 2D Grid Arrangement

```
Input row spacing multiplied by one thousand: #Matrix_arrangement.rsize int
Input column spacing multiplied by one thousand: #Matrix_arrangement.csize int
Input even row offset multiplied by one thousand: #Matrix_arrangement.tab int
Number of rows.: #Matrix_arrangement.Rows int
Number of columns: #Matrix_arrangement.Columns int
Calculate coordinates: execute as b09e-44-fded-6-efa5ffffef64 run function large_number:matrix_arrangement/start

The output is a list of relative coordinates for x and z of the list.
List of relative x values of coordinates.: storage large_number:math matrix_arrangement_X
List of relative z values of coordinates: storage large_number:math matrix_arrangement_Z

An example using function macros to access the coordinate list: execute positioned x y z rotated x y run function large_number:matrix_arrangement/summon
Pass in the execution position and execution orientation.
```

　

♦ Second Order Bezier Curve

Formula: 

$$
B\left ( t \right )=\left ( 1-t \right )^2P_0+2t\left ( 1-t \right )P_1+t^2P_2,\ t\in \left [ 0,1 \right ]
$$

```
Input

Input coordinates of three points multiplied by one thousand: 
#bezier_curve_II.P0.x int
#bezier_curve_II.P0.y int
#bezier_curve_II.P0.z int

#bezier_curve_II.P1.x int
#bezier_curve_II.P1.y int
#bezier_curve_II.P1.z int

#bezier_curve_II.P2.x int
#bezier_curve_II.P2.y int
#bezier_curve_II.P2.z int

Input step size of t multiplied by ten thousand: #bezier_curve_II.t.size int

Calculate coordinates: function large_number:particle/bezier_curve_2/start

Output relative coordinate list: 
storage large_number:math bezier_curve_II_list

Display particles: execute positioned x y z rotated x y run function large_number:particle/bezier_curve_2/particle
Pass in the execution position and execution orientation.
```

　

♦ Heart Shape Curve

Formula: 

$$
\begin{aligned}
& \mathrm{Upper\ Half:\ }\sqrt {r\left | {x} \right |-{x}^{2}} \\
& \mathrm{Lower\ Half:\ }\frac {r} {2}\left ( {\arccos {\left ( {1-\left | {\frac {2x} {r}} \right |} \right )}-\pi} \right )
\end{aligned}
$$

```
Radius (multiplied by ten thousand): #heart-shaped_line.r int
Particle density for upper segment (in degrees, multiplied by one hundred): #heart-shaped_line.t_d int
Particle density for lower segment (in units, multiplied by ten thousand): #heart-shaped_line.t int

Connect the points at the break in the heart shape curve to join the image (number of points to connect): #heart-shaped_line.extra int
Adjust the width of the points drawn to fix the image (in units of grids, multiplied by ten thousand): #heart-shaped_line.t_x int
The discontinuity between the upper and lower segments of the heart shape curve is due to calculation errors.

Calculate coordinates: 
execute as b09e-44-fded-6-efa5ffffef64 run function large_number:particle/heart-shaped_line/start

Output relative coordinate list: storage large_number:math heart-shaped_line_Pos
Each sublist contains x as the first item and y as the second item.

Display particles: execute positioned x y z rotated x y run function large_number:particle/heart-shaped_line/particle
Pass in the execution position and execution orientation.
```

　

♦ Color Wheel

```
Displaying the Color Circle: execute positioned x y z rotated x y run function large_number:color_wheel/particle1
Pass in the execution position and execution orientation.

Input angle of the color pointer on the Color Circle (in degrees, counterclockwise, multiplied by ten thousand): #color_wheel.angle.input int
Input range from [0,3600000]
Mark the position pointed by the Color Circle pointer with particles: set #color_wheel.see_marker int 1
Calculate the color information of the hue cube: function large_number:color_wheel/in/start

Output RGB value at the position of the Color Circle pointer: 
#color_wheel.output.R int
#color_wheel.output.G int
#color_wheel.output.B int
Table of particle information for the hue cube: storage large_number:math color_wheel_color_cube_RGB

Displaying the Hue Cube: execute positioned x y z rotated x y run function large_number:color_wheel/in/particle/start
Pass in the execution position and execution orientation.

Input color coordinates of the hue cube multiplied by ten thousand (both in percentages): 
#color_cube.u int
#color_cube.v int
Here, 'u' represents the horizontal distance between the color coordinates and the top-right starting point of the hue cube, while 'v' represents the vertical distance between the color coordinates and the top-right starting point of the hue cube. 
Input range is [0, 10000] for both.

Calculate color coordinates: function large_number:color_wheel/in/ope_uv_color/start

Output RGB value: 
#color_cube.R int
#color_cube.G int
#color_cube.B int
```

　

♦ Straight Line

```
1000 times the input total length：#3d_straight_line.length int
1000 times the input point spacing：#3d_straight_line.density int

Calculate coordinates：function large_number:particle/3d_straight_line/start

Output relative coordinate list：storage large_number:math 3d_straight_line_Pos
A straight line is a one-dimensional figure, so it has only one variable.

Display particles：execute positioned x y z rotated x y run function large_number:particle/3d_straight_line/particle
Pass in the execution position and execution orientation.
```

　

♦ Regular Polygonal Particle

```
1000 times the input roll angle of the shape：#regular_polygon.startθ int
When the angle is -90, the first vertex of the shape is vertical upwards.
1000 times the input radius of the shape：#regular_polygon.r int
1000 times the input particle spacing：#regular_polygon.size int
Number of sides of the shape：#regular_polygon.n int

Calculate coordinates：
Regular Inscribed Polygon：execute as b09e-44-fded-6-efa5ffffef64 positioned .0 .0 .0 run function large_number:particle/regular_polygon/start
Regular Circumscribed Polygon：execute as b09e-44-fded-6-efa5ffffef64 positioned .0 .0 .0 run function large_number:particle/regular_polygon/tangent_start

Output relative coordinate list：storage large_number:math regular_polygon_Pos
Each primary sublist represents one side of the polygon, where each secondary sublist's first item is x and the second item is y.
Controlling the number of first-level sublists within the list allows you to freely define which edge to display.

Display particles：execute positioned x y z rotated x y run function large_number:particle/regular_polygon/particle
Pass in the execution position and execution orientation.
```

　

♦ N-th Order Bezier Curve

Formula：
$$
B(t)=\sum_{i=0}^{n}P_i
\begin{pmatrix}
n \\
i
\end{pmatrix}
(1-t)^{n-i}t^i,\ t\in[0,1]
$$
Description: Pi represents the coordinates of a point. Pi is calculated by substituting the coordinates of the control points into the formula to determine the curve’s coordinates. In other words, the Bezier curve is computed using a "parametric equation," with the parameter being `t`. 

For example, with three control points: [[x0, y0, z0], [x1, y1, z1], [x2, y2, z2]], you first calculate the curve’s x-coordinate using x0, x1, and x2, then the y-coordinate using y0, y1, and y2, and so on.

`n` is the order. (n, i) is the binomial coefficient, representing the number of combinations of `i` items from `n` items. Formula:
$$
\begin{pmatrix}
n \\
i
\end{pmatrix}
=\frac{n!}{i!(n-i)!}
$$

```
Input：large_number:math bezier_curve_N_input []
Input the three-dimensional coordinates of the control points in sequence, with the order = number of points - 1. Supports orders from 1 to 33.

Step size for t input：#bezier_curve_N.t.size int

Calculate coordinates：function large_number:particle/bezier_curve_n/start
A prompt will appear upon completion.

Output the relative coordinate list：
storage large_number:math bezier_curve_n_Pos
Order：#bezier_curve_N.order int

Display particles.：execute positioned x y z rotated x y run function large_number:particle/bezier_curve_n/particle
Pass the execution position and orientation; the base points for displacement and rotation are the curve's first point.
```

　

♦ Determinant

1.Determine whether the input value is a determinant：large_number:determinant/order

Determinant Input Rules: Must have two levels of lists, with each sublist representing a row. If any element in a row is 0, it must be explicitly included; omission of elements is not supported.

For example [[4,15,7],[6,13,4],[28,2,12]] = 

$$
\begin{vmatrix}
 4 & 15 & 7 \\
 6 & 13 & 4 \\
 28 & 2 &12
\end{vmatrix}
$$

```
Input：storage large_number:math determinant_evaluate.input [[4,15,7],[6,13,4],[28,2,12]]

Order：#determinant.order int
-1 indicates an error in the input determinant.
```

2.Basic Determinant Evaluation：large_number:determinant/evaluate/start

Supports only orders from 1 to 7. The input values must be int.

The determinant is evaluated using the method of algebraic cofactors, expanding row by row, ultimately breaking down higher-order determinants into multiple 3x3 determinants.

```
Input：storage large_number:math determinant_evaluate.input [[4,15,7],[6,13,4],[28,2,12]]

Output：storage large_number:math determinant_evaluate.output
Order：storage large_number:math determinant_evaluate.order
```

3.Inversion Count of Integer Lists：large_number:determinant/inversion_number/start

The list is considered to be in ascending order if it is arranged from smallest to largest.

```
Input：storage large_number:math invers_num_inp [0,1,7,9,6,14,28,5]

Output：#invers_num.output int
If the input list has no duplicate items and the inversion count equals ("number of elements"−1)×"number of elements"/2, then the list elements are arranged in descending order.
```

　

♦ Combination Number：large_number:combinations/start

The number of ways to choose `k` elements from `n` elements.

```
n：#combinations.n int  Range：[0,33]
k：#combinations.k int

Output: The return value of the function.
```

　

♦ Reference: 

> 小豆数学库: https: //github.com/xiaodou8593/math2.0
>
> 知乎.手动开根——牛顿迭代法: https: //zhuanlan.zhihu.com/p/497508702
>
> 知乎.手动开根——竖式开方法: https: //zhuanlan.zhihu.com/p/517358606
>
> 小豆.用命令做一个简易的开根号: https: //www.bilibili.com/read/cv5789989
>
> 天起源.T算法库: https: //www.mcmod.cn/class/11569.html
>
> 计算机系统数学原理: http: //mathmu.github.io/publications/mathematical-theory-of-computer-algebra-system
>
> 【动画密码学】Base64编码&解码算法: https: //www.bilibili.com/video/BV1Hp4y1g7Ex
>
> 卡儿.实数平方根的估值与连分数展开 (提取码 sr8j): https: //pan.baidu.com/s/1eoeChhk7xukIIYxexmMwJQ?pwd=sr8j
>
> 知乎.最大公约数GCD算法: https: //zhuanlan.zhihu.com/p/38100838
>
> 卡儿.《我的世界》【1.16.5】Java版实用粒子教程: https: //www.bilibili.com/read/readlist/rl651851
>
> 数值分析 第五版 (李庆扬 王能超 易大义) (提取码：dker)：https://pan.baidu.com/s/17aYm5onfSbsxH4TmL00mmQ?pwd=dker 

Tool: GeoGebra，Desmos，Excel，Python

